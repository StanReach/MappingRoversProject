// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package nl.vu.cs.s2.simbadtest;


import java.util.Random;
import simbad.sim.Agent;
import simbad.sim.RobotFactory;

import javax.vecmath.Point3d;
import javax.vecmath.Vector3d;


public class MappingRover extends Rover{
	
	Vector3d pos;
	String name;
	
  	String currentMode = null;
  	
  	controlCentre mainControlCentre;
  	
  	Random rand = new Random();
  	
  	private static final int object = 1;


	public MappingRover(Vector3d pos, String name, controlCentre mainHub) {
		super(pos, name);
		
		this.pos = pos;
		this.name = name;
		speed = 2;
		
		mainControlCentre = mainHub;
		
        // Add bumpers
        RobotFactory.addBumperBeltSensor(this, 12);
        // Add sonars
        RobotFactory.addSonarBeltSensor(this, 4);    
	}
	/**
	 * 
	 */

	private boolean detectObstacle() {
		if(collisionDetected()) {
			return true;
		}else {return false;}
	}

	/**
	 * 
	 * @param coord 
	 */
	public void sendCollision() {
		mainControlCentre.updateMap(getCoordinates(), object);
	}

    public void performBehavior() {
    	
    	if (this.getCounter() == 20000) {
    		
    		this.currentMode = "finished";
    		
    		this.setTranslationalVelocity(0);
    		
    		if (this.name.equals("MappingRover0")) {
    			
    			mainControlCentre.printMap();
    			mainControlCentre.startDataRover();
    		}
    	
    		
    	} else {
    	// perform the following actions every 5 virtual seconds
    	if (this.getCounter() % 5 == 0 && this.currentMode != "finished") {
	    	if(this.collisionDetected()) {
	    		this.currentMode = "avoidObstacle";
	    	} else {
	    		this.currentMode = "goAround";
	    	}
	        
	    	if(this.currentMode == "goAround") {
	    		// the robot's speed is always 0.5 m/s
	            this.setTranslationalVelocity(0.5);
	            
	    		// frequently change orientation but only by a specific amount
	            
	            if ((getCounter() % 100) == 0) {
	            	
	                rotate(rand.nextInt(2));
	            }    
	        } else {
	        	
	        	sendCollision();
	        	rotate(rand.nextInt(1));
	        }
    	}
    }
    }
}
